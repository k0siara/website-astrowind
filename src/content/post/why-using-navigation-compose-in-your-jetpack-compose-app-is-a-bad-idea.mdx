---
publishDate: 2022-02-13T00:00:00Z
title: 'Why Using Navigation-Compose in Your Jetpack Compose App is a Bad Idea'
excerpt: Navigation Compose issues that will break your Android app and how to avoid them. 
image: '~/assets/images/posts/cover-compose-navigation.png'
tags:
  - android
  - jetpack-compose
---

import CallToAction from '~/components/widgets/CallToAction.astro';

Navigation-Compose to rozwiÄ…zanie nawigacji w Jetpack Compose promowane przez Google'a, ale czy na pewno powinniÅ›my z niego korzystaÄ‡? MoÅ¼e jednak zostaÄ‡ przy starych Fragmentach i uÅ¼ywaÄ‡ Compose wewnÄ…trz w formie ComposeView?

Wszystko ma swoje plusy i minusy, ale zdecydowanie Navigation-Compose ma wiÄ™cej wad niÅ¼ zalet, o czym niedÅ‚ugo sam siÄ™ przekonasz.

W tym artykule opowiem o moich doÅ›wiadczeniach zarÃ³wno z Navigation-Compose jak i z Fragmentami w aplikacji bazujÄ…cej na Jetpack Compose. Dowiesz siÄ™ jakie przeszkody mogÄ… CiÄ™ czekaÄ‡ przy uÅ¼yciu kaÅ¼dego z nich oraz dlaczego uwaÅ¼am, Å¼e na ten moment lepiej pozostaÄ‡ wÅ‚asnie z Fragmentami.

## Rekomendacja Google

SzukajÄ…c rozwiÄ…zaÅ„ do nawigacji w Compose prawdopodobnie od razu natrafisz na bibliotekÄ™ oficjalnie rekomendowanÄ… przez Google, czyli Navigation Compose. Nowy komponent do nawigacji ma wspieraÄ‡ w peÅ‚ni Compose i uÅ‚atwiaÄ‡ Å¼ycie deweloperom.

Brzmi dobrze, ale czy na pewno tak jest? Navigation Compose to framework stworzony z myÅ›lÄ… zarzÄ…dzania cyklem Å¼ycia, nawigacjÄ… i wszystkim wokÃ³Å‚, eliminujÄ…c potrzebÄ™ uÅ¼ywania FragmentÃ³w.

Stworzono nowy graf nawigacji jako kompozycje Composabli (NavHost) zamiast pliku XML, gdzie moÅ¼emy definiowaÄ‡ adresy, do ktÃ³rych aplikacja moÅ¼e nawigowaÄ‡. No wÅ‚aÅ›nie, adresy stringowe jakbyÅ›my tworzyli adres url.

CoÅ› tu nie gra ğŸ¤”

## Adresy ekranÃ³w

TworzÄ…c nawigacjÄ™ dla Compose, deweloperzy z Google stwierdzili, Å¼e najproÅ›ciej bÄ™dzie skopiowaÄ‡ podejÅ›cie z nawigacji z popularnych rozwiÄ…zaÅ„, oferujÄ…cych webowy experience, np. Flutter czy React. KaÅ¼dy ekran posiada swÃ³j adres url.

IdÄ…c coraz bardziej wgÅ‚Ä…b ekranÃ³w czy grafu, adresy byÅ‚yby coraz mocniej zagnieÅ¼dÅ¼one, np.

- `/users` - adres ekranu listy uÅ¼ytkownikÃ³w
- `/users/2` - adres ekranu szegÃ³Å‚Ã³w uÅ¼ytkownika, gdzie id = 2

Teraz nawigujÄ…c siÄ™ do konkretnego ekranu musimy zapamiÄ™taÄ‡ dokÅ‚adnie jaki byÅ‚ jego adres oraz parametry, ktÃ³re rÃ³wnieÅ¼ bÄ™dÄ… musiaÅ‚y znaleÅºÄ‡ siÄ™ w adresie.

W kwestii parametrÃ³w czeka nas jeszcze wiÄ™cej niespodzianek ğŸ‘‡

## Argumenty ekranÃ³w

WczeÅ›niej, uÅ¼ywajÄ…c FragmentÃ³w i Safe Args, mogliÅ›my zdefiniowaÄ‡ w XML, jakie argumenty przyjmuje dany Fragment. Przy tworzeniu akcji z jednego ekranu do drugiego mieliÅ›my automatycznie generowany kod, ktÃ³ry pytaÅ‚ nas o argumenty odpowiedniego typu i pakowaÅ‚ je do Bundle'a. NastÄ™pnie, aby wyodrÄ™bniÄ‡ te argumenty w docelowym Fragmencie, mogliÅ›my uÅ¼yÄ‡ delegata `by navArgs()`, ktÃ³ry robiÅ‚ to za nas automatycznie.

MogliÅ›my przekazywaÄ‡ wiele rÃ³Å¼nych typÃ³w jako parametry, np. Int, String, Boolean, ale takÅ¼e niestandardowe, takie jak enumy, Serializable czy Parcelable.

To w Compose pewnie zrobili to samo, prawda? AleÅ¼ skÄ…d.

Jak juÅ¼ wspomniaÅ‚em wczeÅ›niej, argumenty ekranÃ³w muszÄ… znaleÅºÄ‡ siÄ™ w adresie url ekranu:

1) `/users/{param_1}/details/{param_2}` - jako parametry w Å›cieÅ¼ce (path params)
2) `/details?{param_2}={param_2_value}&{param_3}={param_3_value}` - albo, Å¼eby jeszcze bardziej to skomplikowaÄ‡, moÅ¼emy przekazaÄ‡ teÅ¼ parametry (opcjonalne lub nie) po znaku zapytania

A co z type safety? Nie ma go, o ile sam o to nie zadbasz. JeÅ›li przekaÅ¼esz zÅ‚y parametr to aplikacja siÄ™ zcrashuje.

KaÅ¼dy parametr musi byÄ‡ odpowiednio zadeklarowany w `composable` przy `NavHost`:

```kotlin
NavHost(startDestination = "profile/{userId}") {
    ...
    composable(
        "profile/{userId}",
        arguments = listOf(navArgument("userId") { type = NavType.StringType })
    ) {...}
}
```

A nastÄ™pnie poprawnie wyciÄ…gniÄ™ty jako konkretny typ:

```kotlin
composable(
    "profile?userId={userId}",
    arguments = listOf(navArgument("userId") { defaultValue = "me" })
) { backStackEntry ->
    Profile(backStackEntry.arguments?.getString("userId")) { friendUserId ->
        navController.navigate("profile?userId=$friendUserId")
    }
}
```

De facto teraz nie tylko musiz sam zarzÄ…dzaÄ‡ wszystkimi adresami, ale rÃ³wnieÅ¼ musiz zapamiÄ™taÄ‡ jakie argumenty sÄ… przyjmowane przez dany ekran, jakie sÄ… klucze i typy danych parametrÃ³w oraz ich kolejnoÅ›Ä‡.

Czy dostaniesz bÅ‚Ä™dy podczas kompilacji, jeÅ›li coÅ› pomieszasz? Nie, dopiero pÃ³Åºniej poleci crash w miejscu, gdzie coÅ› jest Åºle podpiÄ™te ğŸ˜…

<CallToAction
    actions={[{
      variant: "primary",
      text: 'DoÅ‚Ä…czam za darmo! ğŸš€',
      href: 'https://mobiledevnews.com',
      target: '_blank',
    }]}
    title="BÄ…dÅº na bieÅ¼Ä…co z Androidem ğŸ“±"
    subtitle="Od czasu tego artykuÅ‚u sporo <b>zmieniÅ‚o siÄ™</b> w Navigation Compose. Chcesz byÄ‡ na bieÅ¼Ä…co? DoÅ‚Ä…cz do newsletter'a i otrzymuj <b>regularne Androidowe update'y</b> na swojÄ… skrzynkÄ™ mailowÄ… ğŸ“¬"
  />

## Wszystko jest Stringiem

CaÅ‚y adres parsowany jest jako adres URL. A co za tym idzie, wszystko musi zostaÄ‡ przekazane jako valid String.

ZaÅ‚oÅ¼my, Å¼e chcemy przekazaÄ‡ taki adres jako jeden z parametrÃ³w ekranu:

```kotlin
val urlParam = "https://translate.google.com/?hl=en&tab=TT"
```

Aby poprawnie znawigowaÄ‡ siÄ™ do ekranu z tym parametrem, jako Å¼e parametr jest rÃ³wnieÅ¼ adresem url, trzeba go najpierw zenokodowaÄ‡:

```kotlin
navController.navigate("path/arg=${URLEncoder.encode(urlParam)}")
```

A potem przy rozpakowaniu w ekranie trzeba go zdekodowaÄ‡:

```kotlin
URLEncoder.decode(bundle.getString("arg_key"))
```

Co wiÄ™cej, jeÅ›li uÅ¼yjesz `URLEncoder.encode(â€¦)` na Stringu, ktÃ³ry zawiera znak â€˜\nâ€™, w aplikacji poleci zcrash z powodu â€˜%0Aâ€™, wiÄ™c jedynym sposobem, aby to zadziaÅ‚aÅ‚o, jest najpierw uÅ¼ycie Base64.

MoÅ¼na wiÄ™c uznaÄ‡, Å¼e API Navigation Compose jest ANTY Type Safe.

## A co z enumami, Serializable i Parcelable?

Jak wspomniaÅ‚em wczeÅ›niej, kaÅ¼dy argument, ktÃ³ry chcemy przekazaÄ‡, niezaleÅ¼nie od typu, musi zostaÄ‡ przekonwertowany na String, aby moÅ¼na go byÅ‚o dodaÄ‡ do adresu ekranu.

### Enumy

Nawigacja w Compose nie pozwala na przekazywanie enumÃ³w jako parametrÃ³w, ale moÅ¼na to Å‚atwo obejÅ›Ä‡. W teorii, moÅ¼emy przekonwertowaÄ‡ go na String, a nastÄ™pnie wywoÅ‚aÄ‡ metodÄ™ `valueOf` na docelowym ekranie, aby odznaleÅºÄ‡ oryginalnÄ… jego ÅºrÃ³dÅ‚owÄ… wartoÅ›Ä‡.

### Parcelable i Serializable

Tu juÅ¼ zaczyna siÄ™ zabawa. Na ten moment przekazywanie argumentu Serializable lub Parcelable nie jest wspierane przez Compose Navigation.

Na Reddicie powstaÅ‚o wiele wÄ…tkÃ³w na ten temat. Kilka osÃ³b wskazaÅ‚o aby skorzystaÄ‡ z `backStackEntry` i tam rÄ™cznie przekazaÄ‡ obiekt, jednak jest to hack i nawet Googlersi przyznali w komentarzach, Å¼e nie dajÄ… gwarancji czy to zawsze zadziaÅ‚a czy nie.

OsobiÅ›cie wielokrotnie w ten sposÃ³b koÅ„czyÅ‚em z crashem apki, wiÄ™c odradzam. Wszystko znajdziesz w wÄ…tku na IssueTracker [tutaj](https://issuetracker.google.com/issues/182194894).

### Czy moÅ¼emy coÅ› z tym zrobiÄ‡?

W teorii da siÄ™, jednak jest to paskudne rozwiÄ…zanie. MoÅ¼emy zserializowaÄ‡ nasz obiekt do JSON'a i przesÅ‚aÄ‡ go jako String (nie zapominajÄ…c oczywiÅ›cie o enkodowaniu i Base64). Na ten moment uznajmy po prostu, Å¼e Google nie wspiera tych typÃ³w. Przepychanie JSON'Ã³w pomiÄ™dzy ekranami to Å¼art.

### Update

WeszÅ‚y maÅ‚e zmiany od wersji `1.0.3` i `NavigationX 2.4.0-alpha10`, a mianowicie moÅ¼emy od teraz stworzyÄ‡ wÅ‚asny `NavType`

ZaÅ‚Ã³Å¼my, Å¼e mamy takÄ… klasÄ™:

```kotlin
@Parcelize
data class Example(val id: String, val name: String) : Parcelable
```

Zdefinujmy teraz nasz `NavType`:

```kotlin
class ExampleNavType : NavType<Example>(isNullableAllowed = false) {
    override fun get(bundle: Bundle, key: String): Example? {
        return bundle.getParcelable(key)
    }

    override fun parseValue(value: String): Example {
        return Gson().fromJson(value, Example::class.java)
    }

    override fun put(bundle: Bundle, key: String, value: Example) {
        bundle.putParcelable(key, value)
    }
}
```

A nastÄ™pnie uÅ¼yÄ‡ w ten sposÃ³b:

```kotlin
NavHost(...) {
    composable("home") {
        Home(
            onClick = {
                 val example = Example("1", "Example")
                 val json = Uri.encode(Gson().toJson(example))
                 navController.navigate("details/$json")
            }
        )
    }
    composable(
        "details/{example}",
        arguments = listOf(
            navArgument("example") {
                type = ExampleNavType()
            }
        )
    ) {
        val example = it.arguments?.getParcelable<Example>("example")
        Details(example)
    }
}
```

WyglÄ…da juÅ¼ nieco lepiej, w porÃ³wnaniu do wczeÅ›niejszego kodu, jednak nadal wymaga skorzystania z JSON'a. WyobraÅº sobie tworzenie takiego custom NavType'u za kaÅ¼dym razem, gdy chccesz przekazaÄ‡ Parcelable czy Serializable. Kolejny zbÄ™dny kod lÄ…duje w naszej aplikacji. Co wiÄ™cej, w momencie pisania tego update'u w artykule w dokumentacji nie byÅ‚o o tym Å¼adnej wzmianki. Czy jest to oficjalnie wspierane? Czas pokaÅ¼e.

## Dlaczego?

Pewnie teraz niektÃ³rzy siÄ™ zastanawiajÄ… - dlaczego to tak Åºle wyglÄ…da? Nie daÅ‚o siÄ™ zrobiÄ‡ prostego i dziaÅ‚ajÄ…cego API do nawigacji w Compose?

Na pewno siÄ™ daÅ‚o, ale dziaÅ‚ajÄ…ce API to zdecydowanie rzadkoÅ›Ä‡ na Androidzie. MoÅ¼liwe, Å¼e Google kierowaÅ‚o siÄ™ w stronÄ™ przekazywania jedynie identyfikatorÃ³w obiektÃ³w do ekranÃ³w i zniechÄ™cania deweloperÃ³w do przepychania ogromnych obiektÃ³w. MiaÅ‚oby to jakiÅ› sens, ale w pojedynczych przypadkach, a tego nie uwzglÄ™dniono.

## Po prostu uÅ¼ywaj FragmentÃ³w

CoÅ›, co na ten moment mogÄ™ Ci zarekomendowaÄ‡ to zostanie przy Fragmentach i starej metodzie nawigacji. ZdajÄ™ sobie sprawÄ™, Å¼e Fragmenty teÅ¼ majÄ… swoje problemy i komplikacje - zmagam siÄ™ z nimi na codzieÅ„. Jednak, wszystkie te problemy sÄ… mi - pewnie Tobie teÅ¼ - znane. Åatwiej jest dodaÄ‡ `ComposeView` do Fragmentu niÅ¼ bawiÄ‡ siÄ™ z nowÄ… nawigacjÄ…, ktÃ³ra na kaÅ¼dym kroku zmusza CiÄ™ do hackowania prostych operacji (np. przekazaniu parametru String).

A, i pamiÄ™taj, Å¼e majÄ…c na ekranie jednoczeÅ›nie Fragment i Composable'a musisz zadbaÄ‡ o obsÅ‚ugÄ™ dwÃ³ch oddzielnych cykli Å¼ycia. W wiÄ™kszoÅ›ci przypadkÃ³w nie jest to problem, ale zdarzajÄ… siÄ™ usecase'y, w ktÃ³rych powstanÄ… maÅ‚e bÅ‚Ä™dy. Zadbaj o uÅ¼ycie dobrej strategii kompozycji w `setViewCompositionStrategy`.

MaÅ‚a podpowiedÅº na koniec - dla zwykÅ‚ego Fragmentu i DialogFragment'u bÄ™dziesz musiaÅ‚ uÅ¼yÄ‡ innych strategii, ale to juÅ¼ temat na inny artykuÅ‚.

DziÄ™ki za uwagÄ™ i miÅ‚ego hackowania Compose'a! ğŸ‘‹