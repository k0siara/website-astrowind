---
publishDate: 2024-04-16T00:00:00Z
title: 'PorÃ³wnywanie obiektÃ³w w Swift za pomocÄ… protokoÅ‚u Equatable'
excerpt: Jak usprawniÄ‡ porÃ³wnywanie obiektÃ³w w Swift za pomocÄ… protokoÅ‚u Equatable? Zobacz na konkretnych przykÅ‚adach.
image: '~/assets/images/posts/cover-equatable.png'
tags:
  - ios
  - swift
---

import CallToAction from '~/components/widgets/CallToAction.astro';

ZgodnoÅ›Ä‡ z protokoÅ‚em Equatable umoÅ¼liwia porÃ³wnywanie obiektÃ³w w Swift pod kÄ…tem ich rÃ³wnoÅ›ci lub nierÃ³wnoÅ›ci przy uÅ¼yciu operatorÃ³w (==) i (!=). DziÄ™ki temu moÅ¼emy na przykÅ‚ad przeprowadzaÄ‡ okreÅ›lone operacje w zaleÅ¼noÅ›ci od tego, czy obiekty sÄ… zgodne lub nie.

Equatable jest bardzo Å‚atwy w implementacji, a co lepsze wiÄ™kszoÅ›Ä‡ podstawowych typÃ³w w standardowej bibliotece Swift jest juÅ¼ z nim zgodna. Jednak, w przypadku tworzenia wÅ‚asnych typÃ³w, konieczne bÄ™dzie zaimplementowanie tego protokoÅ‚u samemu. Podobnie problem moÅ¼emy napotkaÄ‡ porÃ³wnujÄ…c obiekty z zewnÄ™trzych biliotek, ktÃ³re tego protokoÅ‚u nie zaimplementowaÅ‚y.

Przyjrzyjmy siÄ™ jak moÅ¼emy rozwiÄ…zaÄ‡ te problemy ğŸ‘‡

## Jak zapewniÄ‡ zgodnoÅ›Ä‡ z Equatable?

Aby zapewniÄ‡ typowi porÃ³wnywalnoÅ›Ä‡ wystarczy zaimplementowaÄ‡ protokÃ³Å‚ `Equatable`, jak poniÅ¼ej:

```swift
struct Dog: Equatable {
    let id = UUID()
    let name: String
}
```

Teraz moÅ¼emy juÅ¼ porÃ³wnywaÄ‡ obiekty tej struktury dowolnie:

```swift
let dog1 = Dog(name: "Doggo")
let dog2 = Dog(name: "Carly")

// Wynik: false
print(dog1 == dog2) 
```

To wszystko, co musimy zrobiÄ‡ dziÄ™ki automatycznie syntezowanej zgodnoÅ›ci w kompilatorze Swift (ang. "automatically synthesized conformance").

DziÄ™ki czemu? ğŸ¤·â€â™‚ï¸

## Automatycznie syntezowana zgodnoÅ›Ä‡

Wraz ze Swift 4.1 do kompilatora dodano funkcjÄ™ syntezowania protokoÅ‚Ã³w `Equatable` oraz `Hashable`, a dokÅ‚adnie tu: [SE-0185](https://github.com/apple/swift-evolution/blob/main/proposals/0185-synthesize-equatable-hashable.md). DziÄ™ki temu aby porÃ³wnaÄ‡ ze sobÄ… dwa obiekty tego samego typu wystarczy, Å¼e kaÅ¼dy czÅ‚onek tego typu bÄ™dzie implementowaÅ‚ protokÃ³Å‚ `Equatable`. 

Na przykÅ‚ad, struktura poniÅ¼ej jest zgodna z tym protokoÅ‚em, poniewaÅ¼ id (UUID) oraz name (String) sÄ… typami, ktÃ³re domyÅ›lnie wspierajÄ… ten protokÃ³Å‚ i sÄ… z nim zgodne. 

```swift
struct Dog: Equatable {
    let id = UUID()
    let name: String
}
```

Ale weÅºmy pod uwagÄ™ inny przykÅ‚ad ğŸ¤”

```swift
struct Address {
    let city: String
}

struct Person: Equatable {
    let id = UUID()
    let name: String
    let address: Address
}
```

Tu juÅ¼ mamy problem, bo o ile struktura `Person` implementuje protokÃ³Å‚ `Equatable` to `Address` juÅ¼ nie, a wtedy z Xcode dostaniemy bÅ‚Ä…d o treÅ›ci:
> Type â€˜Personâ€™ does not conform to protocol â€˜Equatableâ€™

Aby ten bÅ‚Ä…d naprawiÄ‡, struktura `Address` rÃ³wnieÅ¼ musi implementowaÄ‡ ten protokÃ³Å‚.

<CallToAction
    actions={[{
      variant: "primary",
      text: 'DoÅ‚Ä…czam za darmo! ğŸš€',
      href: 'https://mobiledevnews.com',
      target: '_blank',
    }]}
    title="BÄ…dÅº na bieÅ¼Ä…co z iOS i Swift ğŸ“±"
    subtitle="DoÅ‚Ä…cz do newsletter'a i otrzymuj wiÄ™cej takich treÅ›ci regularnie na swojÄ… skrzynkÄ™ mailowÄ… ğŸ“¬"
  />

## ZewnÄ™trzne biblioteki

A co jeÅ›li nie mamy bezpoÅ›rednio dostÄ™pu do kodu struktury czy klasy? Np. jeÅ›li uÅ¼ywamy typÃ³w dostarczanych przez zewnÄ™trzne biblioteki?

Wtedy z pomocÄ… przychodzÄ… extensiony. ZaÅ‚oÅ¼my, Å¼e chcemy rozszerzyÄ‡ jakÄ…Å› strukturÄ™ o `Equatable`. Wystarczy, Å¼e napiszemy:

```swift
// To jest jakiÅ› typ dostarczony przez zewnÄ™trznÄ… bibliotekÄ™
extension StructFrom3rdPartyLibrary: Equatable { }
```

## WÅ‚asna logika porÃ³wnywania

A co jeÅ›li chcemy porÃ³wnaÄ‡ ze sobÄ… obiekty w pewien specyficzny sposÃ³b?

```swift
struct Phone: Equatable {
    let id = UUID()
    let model: String
    let vendor: String
}
```

ZaÅ‚oÅ¼my, Å¼e chcielibyÅ›my porÃ³wnywaÄ‡ ze sobÄ… obiekty telefonÃ³w tylko i wyÅ‚Ä…cznie na podstawie producenta, czyli w tym przypadku pola `vendor`.

```swift
let phone1 = Phone(model: "Galaxy S10", vendor: "Samsung")
let phone2 = Phone(model: "Galaxy S20", vendor: "Samsung")
```

MoÅ¼emy napisaÄ‡ wÅ‚asnÄ… implementacjÄ™ funkcji porÃ³wnujÄ…cej aby uzyskaÄ‡ porzÄ…dany efekt:

```swift
extension Phone: Equatable {
    static func == (lhs: Phone, rhs: Phone) -> Bool {
        lhs.vendor == rhs.vendor
    }
}

// Wynik: true
print(phone1 == phone2)
```

## A co z enumami?

Spokojnie, enumy sÄ… automatycznie syntezowane, wiÄ™c nie musimy siÄ™ o nic martwiÄ‡. No, o ile ich wszystkie wartoÅ›ci i pola sÄ… porÃ³wnywalne, o czym warto pamiÄ™taÄ‡.

## Podsumowanie

Wnioski? JeÅ›li chcesz porÃ³wnywaÄ‡ obiekty tego samego typu, zastosuj protokÃ³Å‚ `Equatable` zgodnie z tym, co zaprezentowaÅ‚em. MoÅ¼esz opieraÄ‡ siÄ™ na domyÅ›lnej implementacji tego protokoÅ‚u albo napisaÄ‡ wÅ‚asnÄ… logikÄ™ porÃ³wnywania obiektÃ³w.