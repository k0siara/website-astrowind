---
publishDate: 2023-03-31T00:00:00Z
title: 'Problemy z klawiaturÄ… na Androidzie w Jetpack Compose 1.4.0'
excerpt: NiedziaÅ‚ajÄ…ca klawiatura w najnowszej wersji Jetpack Compose, czyli kolejny przypadek braku testÃ³w przez Google przed wydaniem kolejnej wersji biblioteki.
image: https://miro.medium.com/v2/resize:fit:720/format:webp/0*0knRElWeiGOFJj2A
tags:
  - android
  - jetpack-compose
---

import CallToAction from '~/components/widgets/CallToAction.astro';

CaÅ‚kiem niedawno (22 marca 2023) Google wypuÅ›ciÅ‚ nowÄ…, stabilnÄ… wersjÄ™ Jetpack Compose 1.4.0. ByÅ‚a to dobra okazja dla naszego zespoÅ‚u, aby zmigrowaÄ‡ aktualnÄ… wersjÄ™, z ktÃ³rej korzystaliÅ›my w projekcie do wÅ‚aÅ›nie tej, najnowszej. Jak siÄ™ pÃ³Åºniej okazaÅ‚o, wcale nie byÅ‚o to takie proste zadanie...

PodbiliÅ›my wszystko co trzeba i zaczÄ™liÅ›my testy caÅ‚ej aplikacji. Po chwili okazaÅ‚o siÄ™, Å¼e klawiatura i inputy zachowujÄ… siÄ™ nie tak jak powinny w dialogach, ktÃ³re uÅ¼ywaÅ‚y `ComposeView`, a takich przypadkÃ³w byÅ‚o doÅ›Ä‡ sporo.

Co konkretnie siÄ™ dziaÅ‚o?

W standardowym `DialogFragment` z `ComposeView` klawiatura powinna pojawiÄ‡ siÄ™ po klikniÄ™ciu w dowolne pole tekstowe, ale nie dziaÅ‚o siÄ™ nic.

**Zobaczmy co tam siÄ™ dzieje od Å›rodka ðŸ¤”**

## Kod poczÄ…tkowy

Zaczynamy od prostego `DialogFragment`. W moim przypadku uÅ¼yÅ‚em niestandardowego stylu, aby uzyskaÄ‡ dialog peÅ‚noekranowy. W metodzie `onCreateView` zwracany jest nowy `ComposeView` z zawartoÅ›ciÄ… Composable. W kolejnych krokach omÃ³wimy zarÃ³wno funkcjÄ™ `dialogFragmentComposeView(...)` jak i `DialogContent()`.

```kotlin
class DialogExample : DialogFragment() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // Custom style
        setStyle(STYLE_NORMAL, R.style.FullScreenDialog_Light)
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        return dialogFragmentComposeView {
            DialogContent()
        }
    }

    override fun onStart() {
        super.onStart()
        
        // Full screen dialog
        dialog?.window?.setLayout(
            ViewGroup.LayoutParams.MATCH_PARENT, 
            ViewGroup.LayoutParams.MATCH_PARENT,
        )
    }
}
```

NastÄ™pnie zadeklarowaÅ‚em zawartoÅ›Ä‡ dialogu Composable z wykorzystaniem Scaffold i jednego pola tekstowego, aby uÅ‚atwiÄ‡ debugowanie i zrozumienie problemu.

```kotlin
@Composable
fun DialogContent() {
    var text by remember { mutableStateOf("") }

    Scaffold(
        topBar = { TopBar(onBackClicked = {}) },
    ) { paddingValues ->

        Column(
            modifier = Modifier
                .padding(paddingValues)
                .padding(horizontal = 16.dp)
        ) {
            OutlinedTextField(
                value = text,
                onValueChange = { text = it }
            )
        }
    }
}
```

Ostatnim krokiem jest extension `dialogFragmentComposeView(...)`. On posÅ‚uÅ¼y nam do szybkiego stworzenia `ComposeView`, poprawnie skonfigurowanego pod `DialogFragment`.

Konfiguracja zakÅ‚ada, Å¼e:
- Nasz dialog ma byÄ‡ peÅ‚noekranowy, stÄ…d `layoutParams` zostaÅ‚y ustawione na `MATCH_PARENT`
- Strategia kompozycji widoku powinna byÄ‡ ustawiona na `DisposeOnDetachedFromWindow`. TestowaÅ‚em inne opcje wielokrotnie i zawsze dochodziÅ‚o crashy na `DialogFragmentach`.
- UÅ¼ywamy poprawnego (naszego) theme:

```kotlin
fun DialogFragment.dialogFragmentComposeView(
    content: @Composable () -> Unit
): ComposeView {
    return ComposeView(requireContext()).apply {
        layoutParams = ViewGroup.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.MATCH_PARENT
        )

        // Another interesting flaw. If you use other strategies in DialogFragment you may get crashes ðŸ« 
        setViewCompositionStrategy(strategy = ViewCompositionStrategy.DisposeOnDetachedFromWindow)
        
        setContent {
            CustomComposeTheme(
                darkTheme = false
            ) {
                content()
            }
        }
    }
}
```

Oto nasz wynik na ten moment. Jak widzisz w Compose 1.4.0 ten dialog zachowuje siÄ™ niepoprawnie. `TextField` niby uzyskuje focus po klikniÄ™ciu, ale klawiature w ogÃ³e siÄ™ nie pokazuje. Przynajmniej w tej sytuacji moglibyÅ›my dalej pisaÄ‡ klawiaturÄ… podÅ‚Ä…czonÄ… po USB-C, ale zdecydowanie nie o to nam chodziÅ‚o ðŸ˜‚

<p align="center">
  <img src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*rlCk5_Ur-PwdS_SqEiAlgA.gif" alt="Problem z klawiaturÄ… w Compose 1.4.0"/>
</p>

<CallToAction
    actions={[{
      variant: "primary",
      text: 'DoÅ‚Ä…czam za darmo! ðŸš€',
      href: 'https://mobiledevnews.com',
      target: '_blank',
    }]}
    title="BÄ…dÅº na bieÅ¼Ä…co z Androidem ðŸ“±"
    subtitle="DoÅ‚Ä…cz do newsletter'a i otrzymuj wiÄ™cej takich treÅ›ci regularnie na swojÄ… skrzynkÄ™ mailowÄ… ðŸ“¬"
  />

## Czas na Å›ledztwo ðŸ•µï¸â€â™‚ï¸

Kto tu jest winowajcÄ… i jak to naprawiÄ‡? SpÄ™dziÅ‚em kilka godzin na szukaniu przyczyny tego problemu, testowaÅ‚em na 5 rÃ³Å¼nych telefonach, zmieniaÅ‚em podejÅ›cia do obsÅ‚ugi insetÃ³w, pÃ³l tekstowych itp. Nic nie dawawaÅ‚o rezultatu, albo chociaÅ¼ poszlaki gdzie mogÄ™ znaleÅºÄ‡ rozwiÄ…zanie. PrzeszedÅ‚em do Google Issue Tracker'a i zobaczyÅ‚em coÅ› ciekawego, a mianowicie raport bÅ‚Ä™du regresji: https://issuetracker.google.com/issues/262140644

Okazuje siÄ™, Å¼e ÅºrÃ³dÅ‚em caÅ‚ego zamieszania byÅ‚a zmiana w `InputMethodManager` ([dokÅ‚adnie ta linia](https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/androidMain/kotlin/androidx/compose/ui/text/input/InputMethodManager.kt;l=159;drc=16ad8c080ac1284a39ca331e4a6169646b82e62a))

```kotlin
// TODO(b/221889664) Replace with composition local when available.
private fun View.findWindow(): Window? =
    (parent as? DialogWindowProvider)?.window
        ?: context.findWindow()
```

Najbardziej martwiÄ…ce byÅ‚o to, Å¼e ta regresja zostaÅ‚a zgÅ‚oszona 12 grudnia 2022 roku, gdy ktoÅ› testowaÅ‚ Compose 1.4.0-alpha03, czyli ponad 3 miesiÄ…ce przed wydaniem STABILNEJ wersji. To tylko pokazuje jak Google podchodzi do tematu testowania i wydawania swoich bibliotek. To juÅ¼ nie pierwsza sytuacja tego typu. Not cool, Google.

## A moÅ¼e by tak naprawiÄ‡ to samemu? ðŸ‘¨â€ðŸ”§

MiaÅ‚em trochÄ™ czasu po pracy i byÅ‚em ciekaw czy bÄ™dÄ™ w stanie sam ogarnÄ…Ä‡ ten problem. MoÅ¼e finalnie nie zmigrujemy do tej wersji Jetpack Compose, ale chociaÅ¼ pobawiÄ™ siÄ™ i pohackujÄ™. Pod dyskusjÄ… na Issue Tracker udaÅ‚o mi siÄ™ znaleÅºÄ‡ kilka cennych informacji, ktÃ³re uÅ‚atwiÅ‚y mi to zadanie.

PoniewaÅ¼ funkcja `View.findWindow()` sprawdza czy rodzicem widoku jest typu `DialogWindowProvider`, moglibyÅ›my stworzyÄ‡ wÅ‚asnÄ™ wersjÄ™ `ComposeView`, ktÃ³ra implementuje nie tylko `AbstractComposeView`, ale rÃ³wnieÅ¼ `DialogWindowProvider` i nadpisaÄ‡ funkcjÄ™ zwracajÄ…cÄ… okno tak, aby braÅ‚a je z `DialogFragment`u. Brzmi jak sensowny plan to teraz przetestujmy czy rzeczywiÅ›cie ma sens i zadziaÅ‚a.

PoniÅ¼ej w kodzie `DialogFragmentComposeView` przekazujÄ™ dialog w lambdzie jako provider, aby upewniÄ‡ siÄ™, Å¼e jest poprawnie uÅ¼ywany za kaÅ¼dym razem, gdy okno jest wywoÅ‚ywane. Reszta kodu to copy-paste tego, co oryginalnie znajdziesz w `ComposeView`.

```kotlin
internal class DialogFragmentComposeView(
    context: Context,
    private val dialogProvider: () -> Dialog,
) : AbstractComposeView(context, null, 0),
    DialogWindowProvider {

    // Tu jest fix (a raczej hack)
    override val window get() = dialogProvider().window!!

    private val content = mutableStateOf<(@Composable () -> Unit)?>(null)

    override var shouldCreateCompositionOnAttachedToWindow: Boolean = false
        private set

    @Composable
    override fun Content() {
        content.value?.invoke()
    }

    override fun getAccessibilityClassName(): CharSequence = ComposeView::class.java.name

    /**
     * Set the Jetpack Compose UI content for this view.
     * Initial composition will occur when the view becomes attached to a window or when
     * [createComposition] is called, whichever comes first.
     */
    fun setContent(content: @Composable () -> Unit) {
        shouldCreateCompositionOnAttachedToWindow = true
        this.content.value = content
        if (isAttachedToWindow) createComposition()
    }
}

internal var DialogFragmentComposeView.consumeWindowInsets: Boolean
    get() = getTag(androidx.compose.ui.R.id.consume_window_insets_tag) as? Boolean ?: true
    set(value) {
        setTag(androidx.compose.ui.R.id.consume_window_insets_tag, value)
    }
```

PamiÄ™taj, Å¼e nie moÅ¼emy po prostu przekazaÄ‡ dialogu bezpoÅ›rednio z `DialogFragment` do naszego customowego `ComposeView`, poniewaÅ¼ skoÅ„czylibyÅ›my z crashem. W mocnym skrÃ³cie, dialog jest tworzony a potem czyszczony w `onDestroyView`, co nie uÅ‚atwia nam pracy. Dodatkowo Android ma przekombinowany cykl Å¼ycia, ktÃ³ry dziaÅ‚a jak chce - dosÅ‚ownie. Nie Å‚udÅº siÄ™, Å¼e bÄ™dzie dziaÅ‚aÅ‚ zgodnie z dokumentacjÄ….

TestowaÅ‚em rÃ³Å¼ne rozwiÄ…zania, wielokrotnie i finalnie jako, Å¼e dialog bÄ™dzie czyszczony od czasu do czasu, jesteÅ›my zmuszeni dopisaÄ‡ kolejnego hack'a, a konkretnie ðŸ‘‡

```kotlin
dialogProvider = { dialog ?: Dialog(requireContext()) },
```

Musimy zadbaÄ‡ o to, aby "jakiÅ›" dialog zawsze byÅ‚ dostÄ™pny, dlatego najproÅ›ciej (na potrzeby zabawy) stworzyÄ‡ dummy dialog, gdy ten docelowy jest nullem. Przypominam raz jeszcze, my siÄ™ tu bawimy. Nie piszemy rozwiÄ…zaÅ„, ktÃ³re wylÄ…dujÄ… na produkcji. To by byÅ‚o bardzo gÅ‚upie.

```kotlin
fun DialogFragment.dialogFragmentComposeView(
    consumeWindowInsets: Boolean,
    content: @Composable () -> Unit,
): View {
    return DialogFragmentComposeView(
        context = requireContext(),
        dialogProvider = { dialog ?: Dialog(requireContext()) },
    ).apply {
        consumeWindowInsets = consumeWindowInsets
        layoutParams = ViewGroup.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.MATCH_PARENT
        )

        setViewCompositionStrategy(strategy = ViewCompositionStrategy.DisposeOnDetachedFromWindow)
        setContent {
            CustomComposeTheme(
                darkTheme = false
            ) {
                content()
            }
        }
    }
}
```

Voila, naprawione. Albo raczej, jak to mÃ³wiÄ… - u mnie dziaÅ‚a. Problem rozwiÄ…zany to wrzucamy update na produkcjÄ™, prawda?

He he he, nie.

<p align="center">
  <img src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*fb01RpnCA0RP0TkM3p1iMQ.gif" alt="Problem z klawiaturÄ… w Compose 1.4.0"/>
</p>

## To co z tym update'em Compose do 1.4.0?

Nic. Problem jest na tyle krytyczny, Å¼e naleÅ¼aÅ‚o siÄ™ wstrzymaÄ‡ i daÄ‡ sobie na ten moment spokÃ³j. Hack rÃ³wnieÅ¼ pozostawiaÅ‚ wiele do Å¼yczenia, wiÄ™c nie ma tu podstaw do tego, aby ze spokojnym sumieniem wypuÅ›ciÄ‡ uÅ¼ytkownikom takÄ… aplikacjÄ™ z popsutym Compose.

Przy okazji, warto spojrzeÄ‡ na release notes compose-ui 1.4.0 ðŸ‘‰ https://developer.android.com/jetpack/androidx/releases/compose-ui

> The focus system is rewritten using the new experimental Modifier.Node APIs

Sprawa jest jasna. Google przepisaÅ‚o logikÄ™ obsÅ‚ugujÄ…cÄ… focus, bez dobrych testÃ³w i puÅ›cili to na produkcjÄ™, typowo.

No nic, moÅ¼e kolejna wersja Compose bÄ™dzie nieco lepsza ðŸ˜…